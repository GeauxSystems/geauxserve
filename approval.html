/* ========= FIXED APPROVAL FUNCTIONS - COPY AND PASTE THESE ========= */

/**
 * REPLACE YOUR EXISTING apiApproveApplication FUNCTION WITH THIS ENTIRE FUNCTION
 * This fixes:
 * 1. contactRes.contact bug (should be contactRes.data.contact)
 * 2. Date storage (now stores timestamp instead of ISO string)
 */
function apiApproveApplication(contactId) {
  if (!contactId) {
    return { success: false, message: "Contact ID required" };
  }
  
  const cfg = getCfg_();
  const cfMap = getCustomFieldMap_();
  const contactRes = hlFetch_(`/contacts/${contactId}`, "GET");
  
  if (contactRes.status !== 200) {
    return { success: false, message: "Contact not found", debug: contactRes.data };
  }
  
  // FIX #1: Changed from contactRes.contact to contactRes.data.contact
  const contact = contactRes.data.contact;
  const customFields = contact.customFields || [];
  const householdName = getHouseholdName_(contact);
  
  const getCF = (fieldName) => {
    const fieldId = cfMap[fieldName];
    if (!fieldId) return "";
    const cf = customFields.find(f => String(f.id) === String(fieldId));
    return cf ? String(cf.value || "").trim() : "";
  };
  
  const children = parseInt(getCF("FP Children 0–17") || "0");
  const adults = parseInt(getCF("FP Adults 18–64") || "0");
  const seniors = parseInt(getCF("FP Seniors 65+") || "0");
  const householdSize = children + adults + seniors;
  const token = generateToken_(contact);
  const expirationISO = getNextJune30Expiration_();
  
  const CARD_PAGE_URL = "https://littlezion.geauxserve.com/card.html";
  const encodedName = encodeURIComponent(householdName);
  const digitalCardUrl = `${CARD_PAGE_URL}?id=${contactId}&t=${token}&name=${encodedName}`;
  const todayISO = getTodayLouisiana_();
  const needsPhysicalCard = getCF("Needs Physical Card");
  const qrCodeDeliveryMethod = (needsPhysicalCard === "true" || needsPhysicalCard === "Yes") ? "Physical Card Only" : "Both";
  
  const fpHeadOfHouseholdName = householdName;
  const fpPhone = contact.phone || "";
  const fpStreetAddress = contact.address1 || "";
  const fpCity = contact.city || "";
  const fpState = contact.state || "";
  const fpZipCode = contact.postalCode || "";
  
  // IMPROVED SIGNATURE EXTRACTION - handles arrays, objects, strings
  let signatureFromForm = "";
  try {
    const signatureFieldId = cfMap["Signature of Person Filing Application"];
    if (signatureFieldId) {
      const signatureField = customFields.find(f => String(f.id) === String(signatureFieldId));
      const v = signatureField ? signatureField.value : null;

      if (typeof v === "string") {
        signatureFromForm = v.trim();
      } else if (Array.isArray(v) && v.length) {
        const first = v[0];
        if (typeof first === "string") signatureFromForm = first.trim();
        else if (first && typeof first === "object" && first.url) signatureFromForm = String(first.url).trim();
      } else if (v && typeof v === "object" && v.url) {
        signatureFromForm = String(v.url).trim();
      }
    }
  } catch (e) {
    Logger.log("Error getting signature: %s", e.message);
  }
  
  Logger.log("Extracted signature URL: " + (signatureFromForm || "(none)"));
  
  // FIX #2: Changed approval date to timestamp instead of ISO string
  const approvalTimestamp = String(Date.now());
  
  const updatePayload = {
    customFields: [
      { id: cfMap["FP Application Status"], value: "Approved" },
      { id: cfMap["FP Household Token"], value: token },
      { id: cfMap["FP Household Size"], value: String(householdSize) },
      { id: cfMap["FP Application Expiration Date"], value: expirationISO },
      { id: cfMap["Digital Card URL"], value: digitalCardUrl },
      { id: cfMap["FP Service Status"], value: "Pending" },
      { id: cfMap["FP Head of Household Name"], value: fpHeadOfHouseholdName },
      { id: cfMap["FP Phone Number"], value: fpPhone },
      { id: cfMap["FP Street Address"], value: fpStreetAddress },
      { id: cfMap["FP City"], value: fpCity },
      { id: cfMap["FP State"], value: fpState },
      { id: cfMap["FP Zip Code"], value: fpZipCode },
      { id: cfMap["FP Applicant Signature URL"], value: signatureFromForm || "" },
      { id: cfMap["Parish Residency Verified"], value: ["Done"] },
      { id: cfMap["Eligibility Verified (Income or Assistance)"], value: ["Done"] },
      { id: cfMap["Household Size Reviewed"], value: ["Done"] },
      { id: cfMap["One Household per Address Verified"], value: ["Done"] },
      { id: cfMap["Signature Present"], value: signatureFromForm ? ["verified"] : [] },
      { id: cfMap["QR Code Delivery Method"], value: qrCodeDeliveryMethod },
      { id: cfMap["QR Code Sent Date"], value: todayISO },
      { id: cfMap["FP Approval Date"], value: approvalTimestamp }
    ].filter(f => f.id)
  };
  
  Logger.log("Approving application for: %s", householdName);
  const updateRes = hlFetch_(`/contacts/${contactId}`, "PUT", updatePayload);
  
  if (updateRes.status !== 200) {
    Logger.log("ERROR: Update failed with status %s", updateRes.status);
    return { success: false, message: "Failed to update contact: " + JSON.stringify(updateRes.data) };
  }
  
  Logger.log("✓ Contact updated successfully");
  Logger.log("Approved application for %s (Token: %s)", householdName, token);
  
  // Generate and attach PDF - PASS SIGNATURE DIRECTLY
  // TEMPORARILY DISABLED FOR TESTING
  // try {
  //   generateApplicationPDF(contactId, signatureFromForm);
  // } catch (error) {
  //   Logger.log('PDF generation failed: ' + error);
  // }
  
  return {
    success: true,
    message: "Application approved successfully",
    householdName: householdName,
    token: token,
    digitalCardUrl: digitalCardUrl
  };
}

/**
 * REPLACE YOUR EXISTING apiDenyApplication FUNCTION WITH THIS ENTIRE FUNCTION
 * This fixes:
 * 1. contactRes.contact bug (should be contactRes.data.contact)
 * 2. Date storage (now stores timestamp instead of ISO string)
 */
function apiDenyApplication(contactId, reason, notes) {
  if (!contactId) return { success: false, message: "Contact ID required" };
  if (!reason) return { success: false, message: "Denial reason required" };
  
  const cfg = getCfg_();
  const cfMap = getCustomFieldMap_();
  const contactRes = hlFetch_(`/contacts/${contactId}`, "GET");
  
  if (contactRes.status !== 200) {
    return { success: false, message: "Contact not found", debug: contactRes.data };
  }
  
  // FIX #1: Changed from contactRes.contact to contactRes.data.contact
  const contact = contactRes.data.contact;
  const householdName = getHouseholdName_(contact);
  
  // FIX #2: Changed denial date to timestamp instead of ISO string
  const denialTimestamp = String(Date.now());
  
  const updatePayload = {
    customFields: [
      { id: cfMap["FP Application Status"], value: "Denied" },
      { id: cfMap["FP Denial Reason"], value: reason },
      { id: cfMap["FP Denial Notes"], value: notes || "" },
      { id: cfMap["FP Denial Date"], value: denialTimestamp }
    ].filter(f => f.id)
  };
  
  const updateRes = hlFetch_(`/contacts/${contactId}`, "PUT", updatePayload);
  
  if (updateRes.status !== 200) {
    return { success: false, message: "Failed to update contact" };
  }
  
  Logger.log("Denied application for %s (Reason: %s)", householdName, reason);
  return { success: true, message: "Application denied", householdName: householdName };
}

/**
 * ALSO UPDATE YOUR doGet FUNCTION - ADD ERROR HANDLING
 * Replace your entire doGet function with this:
 */
function doGet(e) {
  try {
    const action = e?.parameter?.action || "";
    
    // Scanner Portal Actions
    if (action === "checkin") {
      return apiResponse_(apiScannerCheckIn(e.parameter.id, e.parameter.t));
    }
    if (action === "serve") {
      return apiResponse_(apiScannerServe(e.parameter.id, e.parameter.t));
    }
    
    // Manual Search Action
    if (action === "search") {
      return apiResponse_(apiSearch(e.parameter.query));
    }
    
    // Approval Dashboard Actions
    if (action === "getPendingApplications") {
      return apiResponse_(apiGetPendingApplications());
    }
    if (action === "approveApplication") {
      return apiResponse_(apiApproveApplication(e.parameter.contactId));
    }
    if (action === "denyApplication") {
      return apiResponse_(apiDenyApplication(e.parameter.contactId, e.parameter.reason, e.parameter.notes));
    }
    
    // Check-In Page Actions
    if (action === "loadHousehold") {
      return apiResponse_(apiLoadHousehold(e.parameter.id, e.parameter.token));
    }
    if (action === "verifyPin") {
      return apiResponse_(apiVerifyPin(e.parameter.pin));
    }
    if (action === "checkIn") {
      return apiResponse_(apiCheckIn(e.parameter.id, e.parameter.token, e.parameter.pin));
    }
    if (action === "markServed") {
      return apiResponse_(apiMarkServed(e.parameter.id, e.parameter.token, e.parameter.pin));
    }
    if (action === "serveAnyway") {
      return apiResponse_(apiServeAnyway(e.parameter.id, e.parameter.token, e.parameter.pin));
    }
    if (action === "regenerateCard") {
      return apiRegenerateCard(e);
    }
    
    return apiResponse_({ error: "Invalid action" });
    
  } catch (error) {
    // Catch ALL errors and return JSON response
    Logger.log("doGet error: " + error.toString());
    Logger.log("Stack trace: " + error.stack);
    return apiResponse_({ 
      success: false, 
      error: "Server error: " + error.toString(),
      action: e?.parameter?.action || "unknown"
    });
  }
}
